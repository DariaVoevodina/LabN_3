package labs;

class List_of_shops {//создание класа Список покупок
    //Создание полей класса
    private Shop[] list;//Массив, состоящий из покупок
    private int sum;//Бюджет на совершение покупок
    public List_of_shops(){
        this.list=new Shop[100];//Создаем массив большой ддлины, в котором изначально все элементы null
        this.sum=0;//Изначальный бюджет равен нулю
    }
    //Метод для вывод массива в виде списка покупок
    public String list() {
        String s = "(";//Создаем строку s
        //Идём циклом по длине массива
        for (int i = 0; i < list.length-1; i++) {
            //Если нулевой элемент, то останавливаем вывод
            if (list[i] == null) {
                break;
            } else {
                //Иначе, если элемент после i нулевой, то просто добавляем в строку i элемент
                if (list[i + 1] == null) {
                    s += list[i];
                } else {
                    s += list[i] + ", ";//Если не нулевой, то добавляем i элемент и запятую, тк дальше тоже будет элемент
                }
            }
        }
        s += ")";//Закрываем список по завершению цикла
        return s;//Возвращаем полученную строку
    }
    //Пишем метод addShop для добавления покупок в список
    public void addShop(Shop x){
        int index=0;//Это будет количеситво ненулевых элементов в массиве
        //Идем по циклу, если элемент не ноль увеличиваем счётчик на 1
        for(int i=0;i<list.length;i++) {
            if (list[i] != null) {
                index+=1;
            }
            //Если элемент равен нулю, то добавляем на первое место нулевого элемента,перед которым все ненулевые элементы наш продукт
            if(list[i]==null){
                list[index]=x;
            }
        }
    }
    //Метод addMoney для добавления в бюджет средства
    public int addMoney(int x){
        return sum+=x;
    }
    //Метод mayBuy, который помогает определить возможность покупки того или иного товара
    public String mayBuy(Shop x){
        if(x.price*x.count<=sum){//Если средств в бюджете достаточно для покупки товара, то возвращаем ответ YES
            return "YES";
        }
        else{
            return "NO";//Иначе возвращаем NO
        }
    }
    //Метод buyShop, позволяющий купить покупку из списка, если достаточно средств
    public void buyShop(Shop x){
        //Если достаточно средств на покпку товара, то меняем его статус на куплено и вычитаем из бюджета средства, потраченные на данную покупку
        if(x.price*x.count<=sum){
            x.status="YES";
            sum-=x.price*x.count;
        }
        else{//Иначе не покупаем и статус остаётся NO
            x.status="NO";
        }
    }
    //Метод sumShops считает сумму всех покупок, независо от их статуса
    public int sumShops(){
        int sum_of_shops=0;//счётчик для суммы
        //Идем по массиву, если элемент ненулевой, то добавляем его стоимость в сумму
        for(int i=0;i<list.length;i++){
            if(list[i]!=null) {
                sum_of_shops += list[i].price * list[i].count;
            }
        }
        return sum_of_shops;//Возвращаем сумму
    }
    //Метод sumNotBuyingShops позволяет посчитать сумму, которая необходима для некупленных покупок из списка
    public int sumNotBuyingShops(){
        int sum_not_buying_shops=0;//счётчик суммы
        //Идём по циклу, если элемент ненулевой и его статус NO, то добавляем в сумму его стоимость
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].status=="NO") {
                sum_not_buying_shops += list[i].price * list[i].count;
            }
        }
        return sum_not_buying_shops;//Возвращаем стоимость
    }
    //Метод mayBuyAll проверяет возможность покупки всех товаров из списка
    public String mayBuyAll(){
        int k=0;//Счётчик для суммы
        //идём циклом по длине массива покупок, если элемент ненулевой, то добавдяем в сумму его стоимость
        for(int i=0;i<list.length;i++){
            if(list[i]!=null) {
                k += list[i].price * list[i].count;
            }
        }
        if(k<=sum){
            return "YES";//Если полученная стоимость меньше бюджета пользователя, то возвращаем YES
        }
        else{
            return "NO";//Иначе возвращаем NO
        }
    }
    //Метод notEnoughMoney для подсчёта суммы, нехватающей для покупки всего списка
    public int notEnoughMoney(){
        int k=0;//счётчик для суммы
        //идём циклом по длине массива,если элемент ненулевоё и он не куплен, то добавляем в сумму его стоимость
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].status=="NO") {
                k+= list[i].price * list[i].count;
            }
        }
        if(sum-k<0){//Если недостающая стоисость есть, то возвращаем её
            return (int)Math.abs(sum-k);
        }
        else{
            return 0;//Если денег хватает, то возвращаем 0
        }
    }
    //Метод buyAll - попытка купить все товары из списка
    public String buyAll(){
        int k=0;//Счётчик для суммы всех товаров
        //Идём по массиву циклом, если элемент ненулевой и он не куплен, то добавляем его в сумму
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].status=="NO") {
                k+= list[i].price * list[i].count;
            }
        }
        if(sum-k<0){//Если суммы не хватает на покупку всех товаров то возвращаем сообщение об этом
            return "I can't buy all";
        }
        else{
            //иначе снова идём по циклу и меняем статус всех товаров на  YES, вычитаем из общего бюджета стоимость всех продуктов и возвращаем сообщение, о свершении покупки
            for(int i=0;i<list.length;i++) {
                if (list[i] != null && list[i].status == "NO") {
                    list[i].status = "YES";
                    sum-=k;
                }
            }
            return "I bought!";
        }
    }
    //Метод sortListIncreasing возвращает исходный спискок, в порядке возрастания стоимости
    public void sortListIncreasing(){
        Shop temp;//Создаем переменную типа Shop для сортировки пузырьком
        int index=0;//счётчик для нахождения первого нулевого элемента
        //идём по циклу, если нашли нулевой элемент, то останавливаем циклу и присваеваем index индекс этого элемента
        for(int i=0;i<list.length;i++){
            if(list[i]==null){
                index=i;
                break;
            }
        }
        //Сама сортировка "пузырьком"
        for(int j=1;j<index;j++){//Заводим цикл  j для нахождения без предыдущего элемента, с наибольшей стоимостью
            for(int i=0;i<index-j;i++){//Заводим цикл i  для нахождения без предыдущего элемента, с наибольшей стоимостью
                if(list[i].price*list[i].count>list[i+1].price*list[i].count){//если элемент большей следующего, то меняем их местами через переменную
                    temp=list[i];
                    list[i]=list[i+1];
                    list[i+1]=temp;
                }
            }
        }
    }
    //Метод для упорядочиванния списка по убыванию стоимости товаров
    public void sortListDecreasing(){
        Shop temp;//переменная для сортировки
        int index=0;//переменная для индекса первого нулевого элемента
        //Идём по длине массива, если нашли нулевой элемент, то запоминаем его индепкс, прерываем цикл
        for(int i=0;i<list.length;i++){
            if(list[i]==null){
                index=i;
                break;
            }
        }
        //Сама сортировка
        for(int j=1;j<index;j++){//Заводим цикл  j для нахождения без предыдущего элемента, с наименьшей стоимостью
            for(int i=0;i<index-j;i++){//Заводим цикл i  для нахождения без предыдущего элемента, с наименьшей стоимостью
                if(list[i].price*list[i].count<list[i+1].price*list[i].count){
                    //Переприсваивание значений
                    temp=list[i];
                    list[i]=list[i+1];
                    list[i+1]=temp;
                }
            }
        }
    }
    //Метод mayBuyAmount для вычисления количества товаров, которые можно купить из некупленных
    public int mayBuyAmount(){
        int k=0;//счётчик количества
        int sum1=0;//счётчик стоисоти товаров
        //Цикл по списку, если статус не кпулено и элемент ненулевой, то добавляем его стоимость в сумму
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].status=="NO"){
                sum1+=list[i].price*list[i].count;
                if(sum1>sum){//Если сумма получислась больше ьюджета, то прерываем цикл
                    break;
                }
                else{//Иначе увеличиваем счётчик на 1(это и будет количество товаров, которые можно купить)
                    k++;
                }
            }
        }
        return k;//Возвращаем количество товаров
    }
    //Метод theCheapest для нахождения самого дешевого товара в списке
    public Shop theCheapest(){
        Shop shop=null;//Создаем переменную типа Shop с нулевым значением, в которой и будет самый дешёвый товар
        int min=Integer.MAX_VALUE;//присваиваем минимума какое-то большое значение
        //Идем по списку циклом и находим элемент с наименьшей стоимостью, запоминаем его стоимость
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].price*list[i].count<min){
                min=list[i].count*list[i].price;
            }
        }
        //Снова идём по списку, если стоимость товара равна минимуму, то присваиваемпеременной shop элемент из спискак
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].price*list[i].count==min){
                shop=list[i];
            }
        }
        return shop;//возвращаем этот товар
    }
    //Метод для находжения самого дорогого товара
    public Shop theMostExpensive(){
        Shop shop=null;//Присваиваем переменной типа Shop  нулевое значение(это и будет самый дорогой товар)
        int max=0;//Обнуляем максимум, в нём будет самая большая стоимость товара
        //Идём циклом по массиву, если находим максимальную стоимость присваиваем её максимуму
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].price*list[i].count>max){
                max=list[i].price*list[i].count;
            }
        }
        //Снова цикл для нахождения самой покупки с наибольшей стоимостью
        for(int i=0;i<list.length;i++){
            if(list[i]!=null&&list[i].price*list[i].count==max){
                shop=list[i];//Если нашли то присваиваем переменной shop значение этого элемента
            }
        }
        return shop;//Возвращаем самый дорогой товар в списке
    }

}